# cs221hw10
The most notable thing here is that hill-climbing blows the genetic algorithm out of the water. On my first implementation of hill-climbing (visualized in hill_climb_first.gif), I got a path length of 6870.24, while with the plain genetic algorithm I could never even get close to 10,000. With my final hill-climbing solution (visualized in hill_climb_final.gif, and recorded in hill_climb_shortest_path.tsv), I got a path length of 5750.05, was essentially "pick a random permutation, go downhill, pick another random hill". The gist of this solution was as follows. Pick a random permutation. Run through all possible city swaps. If you find one that yields a permutation fitter than the current one, replace the current one and once again try all possible city swaps. I did let the genetic part of the algorithm run, but really it was dead weight (and as a result I took a nice walk in the canyon in the 20 minutes it took to run). The solution to the question that was asked in climb_chromosome.cc is by default enabled. The hill-climbing can be enabled via instructions in that file.
Other notable design decisions. I seeded my random number generators with constants (42, 314 and 538). This is because I like being able to reproduce my solutions exactly.
I largely started with Eitan's solution for last week. ga-baseline-soln.gif is the visualization of that genetic algorithm. ga-baseline.gif is the visualization I submitted last week.
comparison_hill_climb.gif is comparison.gif plus the results of my final hill-climbing solution.